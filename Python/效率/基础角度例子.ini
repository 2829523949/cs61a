def counted(f):
    '这个函数是一个修饰器，用来计算调用某一个函数的次数'
    def counted(n):
        counted.amount=counted.amount+1
        return f(n)
    counted.amount=0
    return counted 

def memory(f):
    '这个函数是一个修饰器，将被修饰函数的已计算结果储存，避免重复计算'
    '目前的这个修饰器只支持单变量函数，可以在此基础上改造为支持多变量函数'
    box={}
    '这里不把box设置为属性，因为实际上并不需要调用box，这个修饰器仅用于加快计算，如果需要也可以设置为属性'
    def memorized(n):
        if not n in box.keys:
            box[n]=f(n)
        return box[n]
    return memorized 

def exp(x,n):
    if n==0:
        return 1
    else:
        return x*exp(x,n-1)

'以下的函数改进算法，将n与运行时间的关系从线性变为了对数'
def exp_new(x,n):
    if n==0:
        return 1
    elif n%2==0:
        return (x,n/2)**2
    else:
        return x*exp(x,n-1)

def match(a,b):
    '这是一个典型的，幂函数形式增长的函数'
    '此外，在没有使用记忆的情况下，树递归是一种指数函数形式增长的函数'
    amount=0
    for item_a in a:
        for item_b in b:
            if a==b:
                amount=amount+1
    return amount 

def count_frames(f):
    '注意，在定义阶段，只会检查是否有语法错误，函数定义后可以进行赋值（赋属性）操作（函数是一个对象），调用时已经有了赋值/属性'
    '因此，必须要先定义函数再赋值/赋属性，否则就出现语法错误，找不到对象。如果想先定义属性可以设立一个类'
    def counted(n):
        counted.present_frame=counted.present_frame+1
        if counted.present_frame>counted.max_frame:
            counted.max_frame=counted.present_frame
        counted.present_frame=counted.present_frame-1
        return f(n)
    counted.present_frame=0
    counted.max_frame=0
    return counted     